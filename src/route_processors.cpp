#include "route_processors.h"
#include "password_manager.h"
#include "endpoint_logger.h"
#include <iostream>
#include <chrono>
#include <random>
#include <chrono>
#include <sstream>
#include <iomanip>
#include <array>

RouteProcessors::RouteProcessors() {
    system_data_manager_ = std::make_unique<SourcePageDataManager>();
}

RouteProcessors::~RouteProcessors() = default;

void RouteProcessors::initialize(std::shared_ptr<CredentialManager> credential_manager) {
    credential_manager_ = credential_manager;
}

// Login mechanism processor
ApiResponse RouteProcessors::processLoginRequest(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("auth", "Processing login request for route: " + request.route);

    if (!request.is_json_valid) {
        response.setErrorResponse("Invalid JSON format in login request", 400);
        return response;
    }

    // Validate required fields
    if (!request.json_data.contains("username") || !request.json_data.contains("password")) {
        response.setErrorResponse("Missing required fields: username and password", 400);
        return response;
    }

    std::string username = request.json_data["username"];
    std::string password = request.json_data["password"];

    ENDPOINT_LOG_INFO("auth", "Attempting login for user: " + username);

    // Use credential manager for verification
    if (credential_manager_) {
        auto login_result = credential_manager_->authenticate(username, password);
        if (login_result.success) {
            // Use the session token generated by credential manager (already stored in active_sessions)

            nlohmann::json success_response = {
                {"success", true},
                {"message", "Login successful"},
                {"session_token", login_result.session_token},
                {"username", username},
                {"user", {
                    {"username", username},
                    {"role", login_result.user_data.at("role")}
                }},
                {"login_time", login_result.user_data.at("login_time")},
                {"timestamp", std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::chrono::system_clock::now().time_since_epoch()).count()}
            };

            response.setJsonResponse(success_response, 200);
            ENDPOINT_LOG_INFO("auth", "Login successful for user: " + username);
        } else {
            nlohmann::json error_response = {
                {"success", false},
                {"message", login_result.message},
                {"error_code", "AUTHENTICATION_FAILED"},
                {"attempts_remaining", login_result.attempts_remaining},
                {"total_attempts", login_result.total_attempts},
                {"is_banned", login_result.is_banned}
            };

            if (login_result.is_banned) {
                error_response["lockout_remaining_seconds"] = login_result.lockout_remaining_seconds;
                response.setJsonResponse(error_response, 423); // 423 Locked
            } else {
                response.setJsonResponse(error_response, 401);
            }

            ENDPOINT_LOG_INFO("auth", "Login failed for user: " + username + ". Attempts remaining: " + std::to_string(login_result.attempts_remaining));
        }
    } else {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "Credential manager not available"},
            {"error_code", "SYSTEM_ERROR"}
        };

        response.setJsonResponse(error_response, 500);
        ENDPOINT_LOG_ERROR("auth", "Credential manager not available");
    }

    return response;
}

// Logout mechanism processor
ApiResponse RouteProcessors::processLogoutRequest(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("auth", "Processing logout request");

    nlohmann::json logout_response = {
        {"success", true},
        {"message", "Logout successful"},
        {"timestamp", std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count()}
    };

    response.setJsonResponse(logout_response, 200);
    ENDPOINT_LOG_INFO("auth", "Logout processed successfully");

    return response;
}

// Session validation processor
ApiResponse RouteProcessors::processSessionValidation(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("auth", "Processing session validation request");

    // Extract session token from headers or JSON body
    std::string session_token;
    if (request.headers.count("Authorization")) {
        session_token = request.headers.at("Authorization");
        // Remove "Bearer " prefix if present
        if (session_token.substr(0, 7) == "Bearer ") {
            session_token = session_token.substr(7);
        }
    } else if (request.is_json_valid && request.json_data.contains("session_token")) {
        session_token = request.json_data["session_token"];
    }

    if (session_token.empty()) {
        response.setErrorResponse("No session token provided", 401);
        return response;
    }

    // Validate session with credential manager
    bool is_valid = false;
    if (credential_manager_) {
        is_valid = credential_manager_->validateSession(session_token);
        ENDPOINT_LOG_INFO("auth", "Session token: " + session_token);
        ENDPOINT_LOG_INFO("auth", "Validation result: " + std::string(is_valid ? "VALID" : "INVALID"));
    }

    if (is_valid) {
        nlohmann::json validation_response = {
            {"success", true},
            {"message", "Session is valid"},
            {"session_token", session_token},
            {"timestamp", std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::system_clock::now().time_since_epoch()).count()}
        };

        response.setJsonResponse(validation_response, 200);
        ENDPOINT_LOG_INFO("auth", "Session validation successful");
    } else {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "Invalid or expired session"},
            {"error_code", "SESSION_INVALID"}
        };

        response.setJsonResponse(error_response, 401);
        ENDPOINT_LOG_INFO("auth", "Session validation failed");
    }

    return response;
}

// Echo test processor
ApiResponse RouteProcessors::processEchoRequest(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("utils", "Processing echo request");

    nlohmann::json echo_response = {
        {"success", true},
        {"message", "Echo successful"},
        {"echo_data", request.json_data},
        {"method", request.method},
        {"route", request.route},
        {"timestamp", std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count()}
    };

    response.setJsonResponse(echo_response, 200);
    ENDPOINT_LOG_INFO("utils", "Echo request processed successfully");

    return response;
}

// Health check processor
ApiResponse RouteProcessors::processHealthCheck(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("utils", "Processing health check request");

    nlohmann::json health_response = {
        {"success", true},
        {"status", "healthy"},
        {"message", "Server is operational"},
        {"timestamp", std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count()},
        {"version", "3.0.0"},
        {"architecture", "HTTP-based event architecture"}
    };

    response.setJsonResponse(health_response, 200);
    ENDPOINT_LOG_INFO("utils", "Health check processed successfully");

    return response;
}

// System data processor
ApiResponse RouteProcessors::processSystemDataRequest(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("system", "Processing system data request");

    if (!system_data_manager_) {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "System data manager not available"},
            {"error_code", "SYSTEM_ERROR"}
        };

        response.setJsonResponse(error_response, 500);
        return response;
    }

    // Create a fake API request for the system data manager
    ApiRequest system_request;
    system_request.method = request.method;
    system_request.route = "/api/system-data";

    return system_data_manager_->processSystemDataRequest(system_request);
}

// Dashboard data processor using global dashboard system
ApiResponse RouteProcessors::processDashboardDataRequest(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("dashboard", "Processing dashboard data request");

    if (!DashboardGlobals::g_data_initialized.load()) {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "Dashboard system not initialized"},
            {"error_code", "DASHBOARD_NOT_INITIALIZED"}
        };

        response.setJsonResponse(error_response, 500);
        ENDPOINT_LOG_ERROR("dashboard", "Dashboard system not initialized");
        return response;
    }

    try {
        // Record request start time for performance tracking
        auto start_time = std::chrono::high_resolution_clock::now();

        // Check for refresh parameter and request type
        bool force_refresh = false;
        std::string request_type = "";
        bool include_license_data = false;

        if (request.method == "POST" && !request.body.empty()) {
            try {
                nlohmann::json request_data = nlohmann::json::parse(request.body);
                if (request_data.contains("refresh") && request_data["refresh"].is_boolean()) {
                    force_refresh = request_data["refresh"];
                }
                if (request_data.contains("force_refresh") && request_data["force_refresh"].is_boolean()) {
                    force_refresh = request_data["force_refresh"];
                }
                if (request_data.contains("request_type") && request_data["request_type"].is_string()) {
                    request_type = request_data["request_type"];
                }
                if (request_data.contains("include_license_status") && request_data["include_license_status"].is_boolean()) {
                    include_license_data = request_data["include_license_status"];
                }
                if (request_data.contains("include_license_features") && request_data["include_license_features"].is_boolean()) {
                    include_license_data = include_license_data || request_data["include_license_features"];
                }

                // If request type is license_data, automatically include license data
                if (request_type == "license_data") {
                    include_license_data = true;
                }
            } catch (const std::exception& e) {
                ENDPOINT_LOG_ERROR("dashboard", "Error parsing request body: " + std::string(e.what()));
            }
        }

        // Get dashboard data
        std::string dashboard_json;
        if (force_refresh) {
            ENDPOINT_LOG_INFO("dashboard", "Force refresh requested");
            dashboard_json = DashboardGlobals::getRefreshedDashboardResponse();
        } else {
            dashboard_json = DashboardGlobals::getDashboardResponse(true, true);
        }

        // Parse and enhance the response
        nlohmann::json dashboard_data = nlohmann::json::parse(dashboard_json);
        dashboard_data["success"] = true;
        dashboard_data["request_method"] = request.method;
        dashboard_data["force_refresh"] = force_refresh;

        // Add license data if requested
        if (include_license_data) {
            ENDPOINT_LOG_INFO("dashboard", "Including license data in dashboard response");

            try {
                // Create mock license data for demonstration
                // In production, this would call actual license validation APIs
                nlohmann::json license_data = {
                    {"status", "Active"},
                    {"license_type", "Enterprise Subscription"},
                    {"license_id", "ENT-2025-URW-A7B9"},
                    {"start_date", "2025-03-15"},
                    {"expiry_date", "2026-03-15"},
                    {"days_remaining", 247},
                    {"health_score", 98},
                    {"next_validation_days", 7},
                    {"features", nlohmann::json::array({
                        "Real-time Monitoring",
                        "Advanced Analytics", 
                        "Multi-device Support",
                        "Cloud Synchronization",
                        "Priority Support"
                    })},
                    {"last_validated", "2025-08-24T10:30:00Z"},
                    {"validation_server", "license.ultima-robotics.com"},
                    {"license_fingerprint", "SHA256:a7b9c3d2e1f0..."}
                };

                dashboard_data["license"] = license_data;
                ENDPOINT_LOG_INFO("dashboard", "License data added to dashboard response");

            } catch (const std::exception& e) {
                ENDPOINT_LOG_ERROR("dashboard", "Error adding license data: " + std::string(e.what()));
                // Add error info instead of failing the entire request
                dashboard_data["license"] = {
                    {"status", "Error"},
                    {"error", "Failed to retrieve license information"}
                };
            }
        }

        // Calculate response time
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
        double response_time_ms = static_cast<double>(duration.count());

        dashboard_data["response_time_ms"] = response_time_ms;

        // Record performance statistics
        DashboardGlobals::recordRequest(response_time_ms, true);

        response.setJsonResponse(dashboard_data, 200);
        ENDPOINT_LOG_INFO("dashboard", "Dashboard data processed successfully in " + std::to_string(response_time_ms) + "ms");

    } catch (const std::exception& e) {
        // Record failed request
        DashboardGlobals::recordRequest(0.0, false);

        nlohmann::json error_response = {
            {"success", false},
            {"message", "Failed to retrieve dashboard data"},
            {"error", e.what()},
            {"error_code", "DASHBOARD_ERROR"}
        };

        response.setJsonResponse(error_response, 500);
        std::cerr << "[DASHBOARD-PROCESSOR] Error processing dashboard request: " << e.what() << std::endl;
    }

    return response;
}

// Isolated System Component Processor
ApiResponse RouteProcessors::processSystemComponentRequest(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("system", "Processing isolated system data request");

    if (!DashboardGlobals::g_data_initialized.load()) {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "Dashboard system not initialized"},
            {"error_code", "DASHBOARD_NOT_INITIALIZED"}
        };

        response.setJsonResponse(error_response, 500);
        return response;
    }

    try {
        auto start_time = std::chrono::high_resolution_clock::now();

        // Check for refresh parameter
        bool force_refresh = false;
        if (request.method == "POST" && !request.body.empty()) {
            try {
                nlohmann::json request_data = nlohmann::json::parse(request.body);
                if (request_data.contains("refresh") && request_data["refresh"].is_boolean()) {
                    force_refresh = request_data["refresh"];
                }
                if (request_data.contains("force_refresh") && request_data["force_refresh"].is_boolean()) {
                    force_refresh = request_data["force_refresh"];
                }
            } catch (const std::exception& e) {
                ENDPOINT_LOG_ERROR("system", "Error parsing request body: " + std::string(e.what()));
            }
        }

        // Update system data if refresh requested
        if (force_refresh) {
            DashboardGlobals::updateSystemData(true);
        }

        // Get isolated system data
        SystemInfo system_info = DashboardGlobals::getCurrentSystemInfo();

        nlohmann::json system_response = {
            {"system", {
                {"cpu_usage_percent", system_info.cpu_usage_percent},
                {"cpu_cores", system_info.cpu_cores},
                {"cpu_model", system_info.cpu_model},
                {"cpu_temp_celsius", system_info.cpu_temp_celsius},
                {"cpu_base_clock_ghz", system_info.cpu_base_clock_ghz},
                {"cpu_boost_clock_ghz", system_info.cpu_boost_clock_ghz},
                {"ram_usage_percent", system_info.ram_usage_percent},
                {"ram_used_gb", system_info.ram_used_gb},
                {"ram_total_gb", system_info.ram_total_gb},
                {"ram_available_gb", system_info.ram_available_gb},
                {"ram_type", system_info.ram_type},
                {"swap_usage_percent", system_info.swap_usage_percent},
                {"swap_used_mb", system_info.swap_used_mb},
                {"swap_total_gb", system_info.swap_total_gb},
                {"swap_available_gb", system_info.swap_available_gb},
                {"swap_priority", system_info.swap_priority}
            }},
            {"success", true},
            {"data_age_seconds", DashboardGlobals::getDataAge("system")},
            {"force_refresh", force_refresh},
            {"timestamp", DashboardGlobals::Internal::timestampToString(std::chrono::steady_clock::now())}
        };

        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
        system_response["response_time_ms"] = static_cast<double>(duration.count());

        response.setJsonResponse(system_response, 200);
        ENDPOINT_LOG_INFO("system", "System data processed successfully");

    } catch (const std::exception& e) {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "Failed to retrieve system data"},
            {"error", e.what()},
            {"error_code", "SYSTEM_DATA_ERROR"}
        };

        response.setJsonResponse(error_response, 500);
        ENDPOINT_LOG_ERROR("system", "Error processing system data: " + std::string(e.what()));
    }

    return response;
}

// Isolated Network Component Processor
ApiResponse RouteProcessors::processNetworkComponentRequest(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("network", "Processing isolated network data request");

    if (!DashboardGlobals::g_data_initialized.load()) {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "Dashboard system not initialized"},
            {"error_code", "DASHBOARD_NOT_INITIALIZED"}
        };

        response.setJsonResponse(error_response, 500);
        return response;
    }

    try {
        auto start_time = std::chrono::high_resolution_clock::now();

        // Check for refresh parameter
        bool force_refresh = false;
        if (request.method == "POST" && !request.body.empty()) {
            try {
                nlohmann::json request_data = nlohmann::json::parse(request.body);
                if (request_data.contains("refresh") && request_data["refresh"].is_boolean()) {
                    force_refresh = request_data["refresh"];
                }
                if (request_data.contains("force_refresh") && request_data["force_refresh"].is_boolean()) {
                    force_refresh = request_data["force_refresh"];
                }
            } catch (const std::exception& e) {
                ENDPOINT_LOG_ERROR("network", "Error parsing request body: " + std::string(e.what()));
            }
        }

        // Update network data if refresh requested
        if (force_refresh) {
            DashboardGlobals::updateNetworkData(true);
        }

        // Get isolated network data
        NetworkInfo network_info = DashboardGlobals::getCurrentNetworkInfo();

        nlohmann::json network_response = {
            {"network", {
                {"internet_connected", network_info.internet_connected},
                {"internet_status", network_info.internet_status},
                {"external_ip", network_info.external_ip},
                {"dns_primary", network_info.dns_primary},
                {"dns_secondary", network_info.dns_secondary},
                {"latency_ms", network_info.latency_ms},
                {"download_speed_mbps", network_info.download_speed_mbps},
                {"upload_speed_mbps", network_info.upload_speed_mbps},
                {"server_connected", network_info.server_connected},
                {"server_status", network_info.server_status},
                {"server_hostname", network_info.server_hostname},
                {"server_port", network_info.server_port},
                {"server_protocol", network_info.server_protocol},
                {"last_ping_ms", network_info.last_ping_ms},
                {"session_duration", network_info.session_duration},
                {"connection_type", network_info.connection_type},
                {"interface_name", network_info.interface_name},
                {"mac_address", network_info.mac_address},
                {"local_ip", network_info.local_ip},
                {"gateway_ip", network_info.gateway_ip},
                {"connection_speed", network_info.connection_speed}
            }},
            {"success", true},
            {"data_age_seconds", DashboardGlobals::getDataAge("network")},
            {"force_refresh", force_refresh},
            {"timestamp", DashboardGlobals::Internal::timestampToString(std::chrono::steady_clock::now())}
        };

        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
        network_response["response_time_ms"] = static_cast<double>(duration.count());

        response.setJsonResponse(network_response, 200);
        ENDPOINT_LOG_INFO("network", "Network data processed successfully");

    } catch (const std::exception& e) {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "Failed to retrieve network data"},
            {"error", e.what()},
            {"error_code", "NETWORK_DATA_ERROR"}
        };

        response.setJsonResponse(error_response, 500);
        ENDPOINT_LOG_ERROR("network", "Error processing network data: " + std::string(e.what()));
    }

    return response;
}

// Isolated Cellular Component Processor
ApiResponse RouteProcessors::processCellularComponentRequest(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("cellular", "Processing isolated cellular data request");

    if (!DashboardGlobals::g_data_initialized.load()) {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "Dashboard system not initialized"},
            {"error_code", "DASHBOARD_NOT_INITIALIZED"}
        };

        response.setJsonResponse(error_response, 500);
        return response;
    }

    try {
        auto start_time = std::chrono::high_resolution_clock::now();

        // Check for refresh parameter
        bool force_refresh = false;
        if (request.method == "POST" && !request.body.empty()) {
            try {
                nlohmann::json request_data = nlohmann::json::parse(request.body);
                if (request_data.contains("refresh") && request_data["refresh"].is_boolean()) {
                    force_refresh = request_data["refresh"];
                }
                if (request_data.contains("force_refresh") && request_data["force_refresh"].is_boolean()) {
                    force_refresh = request_data["force_refresh"];
                }
            } catch (const std::exception& e) {
                ENDPOINT_LOG_ERROR("cellular", "Error parsing request body: " + std::string(e.what()));
            }
        }

        // Update cellular data if refresh requested
        if (force_refresh) {
            DashboardGlobals::updateCellularData(true);
        }

        // Get isolated cellular data
        CellularInfo cellular_info = DashboardGlobals::getCurrentCellularInfo();

        nlohmann::json cellular_response = {
            {"cellular", {
                {"has_signal", cellular_info.has_signal},
                {"signal_status", cellular_info.signal_status},
                {"signal_bars", cellular_info.signal_bars},
                {"rssi_dbm", cellular_info.rssi_dbm},
                {"rsrp_dbm", cellular_info.rsrp_dbm},
                {"rsrq_db", cellular_info.rsrq_db},
                {"sinr_db", cellular_info.sinr_db},
                {"cell_id", cellular_info.cell_id},
                {"is_connected", cellular_info.is_connected},
                {"connection_status", cellular_info.connection_status},
                {"network_name", cellular_info.network_name},
                {"technology", cellular_info.technology},
                {"band", cellular_info.band},
                {"apn", cellular_info.apn},
                {"data_usage_mb", cellular_info.data_usage_mb}
            }},
            {"success", true},
            {"data_age_seconds", DashboardGlobals::getDataAge("cellular")},
            {"force_refresh", force_refresh},
            {"timestamp", DashboardGlobals::Internal::timestampToString(std::chrono::steady_clock::now())}
        };

        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
        cellular_response["response_time_ms"] = static_cast<double>(duration.count());

        response.setJsonResponse(cellular_response, 200);
        ENDPOINT_LOG_INFO("cellular", "Cellular data processed successfully");

    } catch (const std::exception& e) {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "Failed to retrieve cellular data"},
            {"error", e.what()},
            {"error_code", "CELLULAR_DATA_ERROR"}
        };

        response.setJsonResponse(error_response, 500);
        ENDPOINT_LOG_ERROR("cellular", "Error processing cellular data: " + std::string(e.what()));
    }

    return response;
}

// Change password mechanism processor
ApiResponse RouteProcessors::processChangePassword(const ApiRequest& request) {
    ApiResponse response;

    ENDPOINT_LOG_INFO("auth", "Processing change password request");

    try {
        // Parse request data
        if (!request.json_data.contains("current_password") ||
            !request.json_data.contains("new_password") ||
            !request.json_data.contains("confirm_password") ||
            !request.json_data.contains("username")) {

            nlohmann::json error_response = {
                {"success", false},
                {"message", "Missing required fields"},
                {"error_code", "MISSING_FIELDS"}
            };

            response.setJsonResponse(error_response, 400);
            return response;
        }

        std::string username = request.json_data["username"];
        std::string current_password = request.json_data["current_password"];
        std::string new_password = request.json_data["new_password"];
        std::string confirm_password = request.json_data["confirm_password"];
        std::string session_token = request.headers.count("Authorization") ? 
            request.headers.at("Authorization") : "";

        // Extract Bearer token if present
        if (!session_token.empty() && session_token.substr(0, 7) == "Bearer ") {
            session_token = session_token.substr(7);
        }

        if (credential_manager_) {
            // Create password manager
            auto password_manager = std::make_shared<PasswordManager>(credential_manager_);

            // Process password change
            auto change_result = password_manager->changePassword(
                username, current_password, new_password, confirm_password, session_token
            );

            if (change_result.success) {
                nlohmann::json success_response = {
                    {"success", true},
                    {"message", change_result.message},
                    {"timestamp", std::chrono::duration_cast<std::chrono::milliseconds>(
                        std::chrono::system_clock::now().time_since_epoch()).count()}
                };

                response.setJsonResponse(success_response, 200);
                ENDPOINT_LOG_INFO("auth", "Password changed successfully for user: " + username);
            } else {
                nlohmann::json error_response = {
                    {"success", false},
                    {"message", change_result.message},
                    {"error_code", change_result.error_code},
                    {"timestamp", std::chrono::duration_cast<std::chrono::milliseconds>(
                        std::chrono::system_clock::now().time_since_epoch()).count()}
                };

                int status_code = 400;
                if (change_result.error_code == "INVALID_CURRENT_PASSWORD" || 
                    change_result.error_code == "AUTH_FAILED") {
                    status_code = 401;
                } else if (change_result.error_code == "INTERNAL_ERROR") {
                    status_code = 500;
                }

                response.setJsonResponse(error_response, status_code);
                ENDPOINT_LOG_INFO("auth", "Password change failed for user: " + username + ". Error: " + change_result.message);
            }
        } else {
            nlohmann::json error_response = {
                {"success", false},
                {"message", "Credential manager not available"},
                {"error_code", "INTERNAL_ERROR"}
            };

            response.setJsonResponse(error_response, 500);
            ENDPOINT_LOG_ERROR("auth", "Credential manager not available");
        }
    } catch (const std::exception& e) {
        nlohmann::json error_response = {
            {"success", false},
            {"message", "Internal server error"},
            {"error_code", "INTERNAL_ERROR"},
            {"details", e.what()}
        };

        response.setJsonResponse(error_response, 500);
        ENDPOINT_LOG_ERROR("auth", "Change password error: " + std::string(e.what()));
    }

    return response;
}

// Note: Session token generation is now handled by CredentialManager